\section{Metamorphic Testing}
	\subsection{A Survey on Metamorphic Testing \cite{Segura2016}}
		Segura et al. did an extensive review of metamorphic testing with 119 papers published between 1998 and 2015 to answer four important research questions:
		\begin{enumerate}
			\item RQ1: What improvements to the technique have been made?
			\item RQ2: What are its known application domains?
			\item RQ3: How are experimental evaluations performed?
			\item RQ4: What are the future research challenges?
		\end{enumerate}

		\subsubsection{Properties of good metamorphic relations}
			To answer the first question they first studied the properties of effective metamorphic relations. To select the most effective metamorphic relations to detect faults one must have.
			\begin{itemize}
				\item A good understanding of the problem domain since good metamorphic relations are usually strongly inspired by the semantics of the program under test.
				\item Metamorphic relations that make execution of the follow–up test case as different as possible from the source test case.
				\item Metamorphic relations derived from specific parts of the system since they are more effective than those targeting the whole system.
				\item Formally described metamorphic relations. In particular, a metamorphic relation should be a 3-tuple composed of $i)$ relation between the inputs of the source and follow–up test cases, $ii)$ relation between the outputs of source and follow-up test cases, and $iii)$ program function.
			\end{itemize}

		\subsubsection{Construction of metamorphic relations}
		Composition of Metamorphic Relations (CMR) can be used to construct new metamorphic relations by combining several existing relations. The rationale behind this method is that the resulting relations should embed all properties of the original metamorphic relations, and thus they should provide similar effectiveness with a fewer number of metamorphic relations and test executions. Two metamorphic relations are considered “compositable” if the follow-up test cases of one of the relations can always be used as source test case of the other. The composition is sensitive to the order of metamorphic relations and generalizable to any number of them. Determining whether two metamorphic relations are composable is a manual task. Chen et al. \cite{Chen2016} presented a specification–based tool called METRIC for the identification of metamorphic relations. In this framework, the program specification is used to partition the input domain in terms of categories, choices and complete test frames. The results of an empirical study with 19 participants suggest that METRIC is effective and efficient at identifying metamorphic relations.

		\subsubsection{Generation of source test cases}
		Gotlieb and Botella \cite{Gotlieb2003} presented a framework called Automated Metamorphic Testing (AMT) to automatically generate test data for metamorphic relations. Given the source code of a program written in C and a metamorphic relation, AMT tries to find test cases that violate the relation. The underlying method is based on the translation of the code into an equivalent constraint logic program over finite domains. Other techniques like “special values” and random testing can also be used as source test cases for metamorphic testing. Genetic algorithms have also been used for the selection of source test cases, to maximize the paths traversed in the program under test.

		\subsubsection{Execution of metamorphic test cases}
		The execution of a metamorphic test case is typically performed in two steps. First, a follow–up test case is generated by applying a transformation to the inputs of a source test case. Second, source and follow–up test cases are executed, checking whether their outputs violate the metamorphic relation. \par
		Iterative Metamorphic Testing (IMT) can be used to systematically exploit more information from metamorphic tests, by applying metamorphic relations iteratively. In IMT, a sequence of metamorphic relations is applied in a chain style, by reusing the follow–up test case of each metamorphic relation as the source test case of the next metamorphic relation. \par
		Murphy et al. \cite{Murphy2009} presented a framework named Amsterdam for the automated application of metamorphic testing. The tool takes as inputs the program under test and a set of metamorphic relations, defined in an XML file. Then, Amsterdam automatically runs the program, applies the metamorphic relations and checks the results.
		\subsubsection{Application domains}
		To answer the second question the authors selected the papers where the main objective was a case study. They identified that the most popular use of metamorphic testing was in web services, followed by computer graphics, simulation and modelling, and, embedded systems. They also found some other domains of application like financial software, optimization programs, and encryption programs.
		Some of the research challenges identified by the authors are:
		\begin{itemize}
			\item Lack of guidelines, with step–by–step process to guide testers, experts, and beginners, in the construction of good metamorphic relations.
			\item Prioritisation and minimisation of metamorphic relations: It is worth mentioning that test case minimisation is a NP–hard problem and therefore heuristic techniques should be explored.
			\item Generation of likely metamorphic relations.
			\item Combination of metamorphic relations.
			\item Automated generation of best possible source test cases.
			\item Lack of metamorphic testing tools.
		\end{itemize}



	\subsection{Automatic System Testing of Programs without Test Oracles \cite{Murphy2009}}
		In this paper the authors have demonstrated the usefulness of metamorphic testing in assessing the quality of applications without test oracles. Comparing the outputs of the morphed data still remains a challenge especially if the data set is large or not in human readable format. The authors presented an approach called ``Automated Metamorphic System Testing'' to automate the metamorphic testing by considering the system as a blackbox and checking if the metamorphic properties holds after execution of the system. They also present another approach “Heuristic Metamorphic Testing” to reduce false positives and address some non-determinism. Unlike in the previous papers, here, the authors are focusing to improve the metamorphic testing technique itself. They list some benefits of using metamorphic testing: it can be used on broader domain of applications that display metamorphic properties, and it treats the application under test as a black box and does not require detailed understanding of the source code. They then list some of the limitations of using metamorphic testing:
		\begin{itemize}
			\item	Manual transformation of large input data can be laborious and error-prone. They need special tools to transform the input.
			\item Comparing the outputs(some of which may be very large and/or in not human-readable format) of the input data can be tedious.
			\item Floating point calculations can also lead to imprecision even though the calculations are programmatically correct.
			\item Coming up with the initial test-cases is also a challenge as some defects may only occur under certain inputs.
		\end{itemize}

		Automated Metamorphic System Testing: This technique can be used to test the application in development environment as well as in production as long as the users are only provided the output from the original execution and not the result from transformed input. In this model $i)$ Metamorphic properties are specified by the tester and applied to the input. $ii)$ The original input is fed into the application which is treated as a black-box and a transformation of the input is also generated. $iii)$ That transformed input is fed into a separate instance of the application running in a separate sandbox. $iv)$ When the invocations are finished, the results are compared and if they do not match according to the specifications, there is an error.
		Tester need not write any code and only needs to specify the metamorphic properties. They don’t need to know the source code or other implementation details.
		Amsterdam framework: The metamorphic properties are specified using XML file. The specification consists of three parts: $i)$ how to transform the input, $ii)$ how to execute the program, and, $iii)$ how to compare the outputs.\par
		Heuristic Metamorphic testing: This method allows for small differences in outputs, in a meaningful way according to the application being used to address the problems of false positives and non-determinism. Imprecisions in floating point calculation and representation of irrational number such as may result in failure of metamorphic testing even if the implementation is correct. If two outputs are close enough they are considered the same. The definition of close enough depends on the application and in complex applications checking semantic similarity may also be required.
