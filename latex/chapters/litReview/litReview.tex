% \section{Software testing}
% Testing is an essential activity in software engineering. In the simplest terms, it amounts to observing the execution of a software system to validate whether it behaves as intended and identify potential malfunctions. Testing is widely used in industry for quality assurance. Software testing is a broad term encompassing a wide spectrum of different activities, from the testing of a small piece of code by the developer (unit testing), to the customer validation of a large information system (acceptance testing), to the monitoring at run-time of a network-centric service-oriented application.
\section{Testing in the Presence of Uncertainty \cite{Elbaum2014}}
Uncertainty is present in most systems that are built today, whether introduced by human decisions, machine learning algorithms, external libraries, or sensing variability mostly due to the need to support deep interactions between interconnected software systems and their users and execution environments. In the context of software testing, uncertainty increases the ambiguity of what constitutes the input space and what is deemed as acceptable behavior, which are two key attributes of a test. In this paper, the authors explore the potential directions for dealing with uncertainty during testing.
Two ways to deal with uncertainty are to exercise more control over the inputs provided to the unit under test and to constrain the testing environment. Some uncertainties like those present in systems that deal with the physical world are aleatoric; that is, they cannot be known precisely because of their inherent variability and noise. Epistemic uncertainties are those that could be resolved with enough effort (e.g., over-engineering a sensor-based system to minimize inference errors about the environment)— and resolving them are becoming more numerous and costly, as the systems are becoming increasingly complex. A complementary way to deal with uncertainty at the other end of the testing process is to develop more sophisticated oracles. If the oracles are relaxed too much to tolerate the variations introduced by uncertainties, there is an inherent risk for the uncertain behavior to mask a fault. On the other hand, if the oracles are too narrow it may cause them to generate false positives, resulting in wasted developer's time. The authors provide a set of requirements for adequate handling of uncertainty in testing:
\begin{enumerate}
  \item Specifying input distributions and generating inputs with the help of the distributions instead of using discrete inputs.
  \item Probabilistic oracles that can help distinguish acceptable from unacceptable misbehaviors. These models will also provide the specification of the likelihood of results.
  \item Richer models to represent system and environment uncertainty, so that uncertainties can be connected to test requirements and outcomes. This will help with automated uncertainty quantification.
\end{enumerate}
Not all systems will impose these requirements, and not all techniques will satisfy them. In fact, they expect it will be necessary to develop a suite of techniques for dealing with uncertainty, selected according to system characteristics and the particular forms of uncertainty the system embodies and based on the use of stochastic models and quantitative analyses.

\section{On Testing Non-testable Programs \cite{Weyuker}}
The current testing research activities fall into three categories:
\begin{enumerate}
  \item Develop a sound theoretical basis for testing.
  \item Devise and improve testing methodologies, especially the mechanizable ones.
  \item Define accurate measurement criteria for testing data adequately.
\end{enumerate}
An oracle is a system that determines the correctness of the solution by comparing the system’s output to the one that it predicts. Programs for which such oracles do not exist are called 'non-testable'. The term non-testable is used, from the point of view of correctness testing. If one cannot decide whether or not the output is correct or have to spend some extraordinary amount of resources to do so, testing those systems may not be worth it.
Non-testable programs can be usually classified into three categories:
\begin{enumerate}
  \item Programs that were written to determine the correct answer.
  \item Programs that produce a lot of outputs such that it is hard to verify all of them.
  \item Programs where tester have a misconception (tester believes that he has the oracle even though he might not).
\end{enumerate}
In absence of oracles, the ideal way to test a program is through Pseudo Oracles/Dual Coding. But, due to a great deal of overhead involved pseudo-oracles may not be practical for every situation. A different, and frequently employed course of action is to run the program on 'simplified' data for which the correctness of the results can be accurately and readily determined. The tester then extrapolates from the correctness of the test results on these simple cases to correctness for more complicated cases. In this case, we are deliberately omitting test cases even though these cases may have been identified as important. They are not being omitted because it is not expected that they will yield substantial additional information, but rather because they are impossible, too difficult, or too expensive to check. The problem with using simple test cases is very obvious i.e. it is common for central cases to work perfectly whereas boundary cases to cause errors.
Although non-testable programs occur in all areas of data processing, the problem is undoubtedly most acute in the area of numerical computations, particularly where floating point arithmetic is used. While performing mathematical computations, errors from three sources can creep in:
\begin{enumerate}
  \item The mathematical model used to do the computations.
  \item Programs written to implement the computation.
  \item The features of the environment like round-off, floating point operations etc.
\end{enumerate}
Even in the absence of oracles the users often have a ballpark idea of what the correct answer would look like without knowing the correct answer. In such cases, we make use of partial oracles. It is relatively easier to test the systems on simpler inputs for which the output is known. There is rarely a single correct answer in these types of computations. Rather, the goal is generally an approximation which is within a designated tolerance of the exact solution. The authors finally make five recommendation for items to be considered as a part of documentation during testing.
\begin{enumerate}
  \item The criteria used to select the test data.
  \item The degree to which the criteria were fulfilled.
  \item The test data, the program ran on.
  \item The output of each of each test datum.
  \item How the results were determined to be correct or acceptable.
\end{enumerate}
Although these recommendations do not solve the problem of non-testable programs, however, they do provide information on whether the program should be considered adequately tested or not.
